'use client'

import { useEffect, useRef, useCallback } from 'react'
import { initSyncManager, syncPendingSales } from '@/app/lib/offline/syncManager'

export default function ServiceWorkerRegister() {
  const cleanupRef = useRef<(() => void) | null>(null)
  const registrationRef = useRef<ServiceWorkerRegistration | null>(null)

  const handleServiceWorkerMessage = useCallback((event: MessageEvent) => {
    if (event.data?.type === 'SYNC_OFFLINE_SALES') {
      console.log('Received sync message from Service Worker')
      syncPendingSales()
    }
  }, [])

  useEffect(() => {
    if (typeof window === 'undefined') return

    const registerServiceWorker = async () => {
      if (!('serviceWorker' in navigator)) {
        console.warn('Service Worker not supported')
        return
      }

      try {
        // Register the service worker (generated by next-pwa)
        const registration = await navigator.serviceWorker.register('/sw.js', {
          scope: '/',
          updateViaCache: 'none'
        })

        registrationRef.current = registration
        console.log('Service Worker registered:', registration.scope)

        // Handle updates
        registration.addEventListener('updatefound', () => {
          const newWorker = registration.installing
          if (newWorker) {
            newWorker.addEventListener('statechange', () => {
              if (newWorker.state === 'installed' && navigator.serviceWorker.controller) {
                // New version available
                console.log('New Service Worker available')
                // Auto-activate the new service worker
                newWorker.postMessage({ type: 'SKIP_WAITING' })
              }
            })
          }
        })

        // Check for updates periodically
        const updateInterval = setInterval(() => {
          registration.update().catch(err => {
            console.warn('Service Worker update check failed:', err)
          })
        }, 60 * 60 * 1000) // Check every hour

        // Listen for messages from service worker
        navigator.serviceWorker.addEventListener('message', handleServiceWorkerMessage)

        // Handle controller change (new SW activated)
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          console.log('Service Worker controller changed')
        })

        // Cleanup function
        cleanupRef.current = () => {
          clearInterval(updateInterval)
          navigator.serviceWorker.removeEventListener('message', handleServiceWorkerMessage)
        }

      } catch (error) {
        console.warn('Service Worker registration failed:', error)
      }
    }

    // Register SW
    registerServiceWorker()

    // Initialize sync manager
    const syncCleanup = initSyncManager()

    return () => {
      if (cleanupRef.current) {
        cleanupRef.current()
      }
      if (syncCleanup) {
        syncCleanup()
      }
    }
  }, [handleServiceWorkerMessage])

  return null
}
